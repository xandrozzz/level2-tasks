//Применимость:
//Паттерн command используется в случаях, когда нужно параметризовать объекты с операциями.
//В таком случае можно легко изменить, какие команды будет отправлять объект в определенных ситуациях,
//легко меняя его поведение.
//Также команды используются для создания очередей или планировании операций.
//Так как команда это полноценный объект, его легко хранить, а значит легко отложить или запланировать выполнение команды.
//Еще одно применение паттерна command это отменяемые операции.
//При помощи команд и истории операций легко реализовать систему отмены или повторения уже совершенных действий.
//
//Плюсы:
//Отделение классов, посылающих команды от классов, выполняющих их, тем самым происходит распределение ответственности.
//Легко добавить новые команды, не изменяя при этом большей части существующего кода.
//Возможно реализовать выполнение нескольких простых команд внутри одной сложной.
//
//Минусы:
//Усложнение структуры кода в связи с появлением нового слоя между отправителями и получателями команд.
//
//Примеры использования:
//Паттерн command может быть применен для вызова удаленных сервисов, например баз данных или логгеров.
//Также команды применяются для создания истории операций, отмены или повтора их выполнения,
//с сохранением состояний системы или без.
//Также команды применяются в имплементации очередей или планировщиков событий.
//

package main

import "fmt"

// PowerButton - класс, содержащий объект интерфейса Command
type PowerButton struct {
	command Command
}

// Press - метод вызова инкапсулированной команды
func (b *PowerButton) Press() {
	b.command.Execute()
}

// Command - основной интерфейс паттерна command
type Command interface {
	Execute()
}

// OnCommand - конкретный класс, реализующий интерфейс Command
type OnCommand struct {
	device Device
}

// Execute - реализация метода Execute для конкретного класса OnCommand
func (c *OnCommand) Execute() {
	c.device.On()
}

// OffCommand - другой конкретный класс, реализующий интерфейс Command
type OffCommand struct {
	device Device
}

// Execute - реализация метода Execute для конкретного класса OffCommand
func (c *OffCommand) Execute() {
	c.device.Off()
}

// Device - целевой интерфейс для команды
type Device interface {
	On()
	Off()
}

// Computer - конкретный класс, реализующий интерфейс Device
type Computer struct {
	isOn bool
}

// On - реализация метода On для конкретного класса Computer
func (c *Computer) On() {
	c.isOn = true
	fmt.Println("Turning the computer on")
}

// Off - реализация метода Off для конкретного класса Computer
func (c *Computer) Off() {
	c.isOn = false
	fmt.Println("Turning the computer off")
}

func main() {
	computer := &Computer{} // создание объекта класса Computer

	// создание команды класса OnCommand для объекта класса Computer
	onCommand := &OnCommand{
		device: computer,
	}

	// создание команды класса OffCommand для объекта класса Computer
	offCommand := &OffCommand{
		device: computer,
	}

	// создание объекта для вызова команды OnCommand
	onButton := &PowerButton{
		command: onCommand,
	}
	onButton.Press() // вызов метода Press для вызова инкапсулированной команды

	// создание объекта для вызова команды OnCommand
	offButton := &PowerButton{
		command: offCommand,
	}
	offButton.Press() // вызов метода Press для вызова инкапсулированной команды
}
