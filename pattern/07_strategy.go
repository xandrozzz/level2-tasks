//Применимость:
//Паттерн strategy стоит использовать в случае, когда нужно использовать несколько алгоритмов
//внутри одного объекта, переключаясь между ними во время рантайма.
//Также паттерн стратегии можно использовать для замены нескольких классов,
//отличающихся только определенным поведением.
//Кроме того, алгоритм рационально использовать в случае, когда внутри класса существует условие
//с разными версиями одного и то же алгоритма.
//
//Плюсы:
//Изменение алгоритмов внутри объектов во время рантайма.
//Изолирование имплементации алгоритма от кода, который его использует.
//Возможно добавлять новые стратегии, не изменяя контекст.
//
//Минусы:
//При использовании небольшого количества алгоритмов, и они не должны часто меняться, введение паттерна strategy
//приведет к бессмысленному усложнению кода.
//Разница между стратегиями должна быть точно известна при их использовании.
//
//Примеры использования:
//Паттерн strategy может использоваться для реализации аллокатора ресурсов.
//В таком случае можно легко выбирать алгоритмы аллокации, максимизируя производительность.
//Также паттерн стратегии может быть применен для работы с сетью.
//При помощи различных стратегий можно использовать разные протоколы при отправке или приеме данных.
//Кроме того, паттерн можно использовать для форматирования или сериализации данных.
//Так, при помощи смены стратегии можно легко изменить метод сериализации.
//

package main

import "fmt"

// Sorter - интерфейс для конкретных классов стратегии
type Sorter interface {
	Sort([]int) []int
}

// BubbleSort - конкретный класс стратегии
type BubbleSort struct{}

// Sort - реализация метода Sort классом BubbleSort
func (bs *BubbleSort) Sort(arr []int) []int {
	for i := 0; i < len(arr)-1; i++ {
		for j := 0; j < len(arr)-i-1; j++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
	return arr
}

// InsertionSort - конкретный класс стратегии
type InsertionSort struct{}

// Sort - реализация метода Sort классом InsertionSort
func (is *InsertionSort) Sort(arr []int) []int {
	for i := 1; i < len(arr); i++ {
		for j := 0; j < i; j++ {
			if arr[j] > arr[i] {
				arr[j], arr[i] = arr[i], arr[j]
			}
		}
	}
	return arr
}

// Context - класс, являющийся контекстом для стратегии
type Context struct {
	sorter Sorter // встраивание интерфейса Sorter
}

// SetSorter - метод для установки конкретного класса, реализующего интерфейс Sorter, в объект Context
func (c *Context) SetSorter(sorter Sorter) {
	c.sorter = sorter
}

// ExecuteSort - метод для вызова метода Sort у инкапсулированного объекта интерфейса Sorter
func (c *Context) ExecuteSort(arr []int) []int {
	return c.sorter.Sort(arr)
}

func main() {
	arr := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5} // создание слайса для сортировки

	// создание двух объектов разных классов, реализующих интерфейс Sorter
	bubbleSort := &BubbleSort{}
	insertionSort := &InsertionSort{}

	context := &Context{}                                 // создание объекта контекста
	context.SetSorter(bubbleSort)                         // установка объекта стратегии BubbleSort внутри контекста
	fmt.Println("Bubble Sort:", context.ExecuteSort(arr)) // вывод результатов работы стратегии

	context.SetSorter(insertionSort)                         /// установка объекта стратегии InsertionSort внутри контекста
	fmt.Println("Insertion Sort:", context.ExecuteSort(arr)) // вывод результатов работы стратегии
}
